---------------------------------------------------------------------------------------------------
#Basics:
---------------------------------------------------------------------------------------------------
- https://github.com/basarat/typescript-for-professionals
- Check versions
    node --versions
    node -v

    npm --versions
    npm -v

    npx --versions
    npx -v

- Create new project
    mkdir intro
    cd intro
    npm init -y

- npx tsc --init --rootdir src --outdir lib

- Primitive Types;
    1) boolean
    2) number
    3) string
    4) undefined    (value is not defined)
    5) null     (value is not present)
    6) Symbol
    7) bigint
eg.
    let isPresent: boolean = false;
    let magic: number = 20
    let notDefine: undefined = undefined;
    let notPresent: null = null;
    // let penta: Symbol = Symbol('star');
    // let bigg: bigint = 24n;

    console.log(isPresent);
    console.log(magic);
    console.log(notDefine);
    console.log(notPresent);
    // console.log(penta);
    // console.log(bigg);

- Arrays:
    let regex: RegExp = new RegExp('ab+c');
    let arr1: Array<number> = [1,2,3];
    let arr2: number[] = [1,2,3,4,5,6,7,8,9,10];
    // let set: Set<number> = new Set([1,2,3]);

    console.log(regex);
    console.log(arr1);
    console.log(arr2);
    // console.log(set);

- Tuple:
    let t: [number, number] = [1,2];
    console.log(t);

    t = [10, 50];
    console.log(t);

    // wrong
    // t = [1];                // must have 2 elements
    // t = [1,2,3];

    // t = ['c', 2];       // must have both element of type number

- Type Alias:
    type Point = {x: number, y: number};

    let p1: Point = {x:1, y:2};
    let p2: Point = {x:3, y:22};

    // const p3: Point = {xx:2, y:3};  // wrong
    const p4: Point = {x:2, y:3};
    // p4 = {x:20, y:30};              // const cannot be re-assigned but
    p4.x = 100;
    p4.y = 200;

    console.log(p1);
    console.log(p2);
    console.log(p4);

- Function:
    function add(a: number, b: number): number{
        return a+b;
    }

    function log(message: string): void{
        console.log(message);
    }

    function sum(...values: number[]): number{
        return values.reduce((a,b)=> {
            return a+b
        });
    }

    console.log(add(1,2));
    log("hello");
    console.log(sum(1,2,3,4));
    console.log(sum(1,23));

    // first class function
    type ADD = (a: number, b: number) => number;

    let add1: ADD = (a,b) => {
        return a+b;
    }
    let add2: ADD = (a,b)=> {
        return a+b;
    }
    console.log(add1(10,22));
    console.log(add2(1,2));

- Structural:
    type User = { id: string};
    type Product = { id: string};

    let user: User = {id: '1'};
    let product: Product = {id: '2'};

    // this is ok, both have same structure
    console.log(product);
    product = user
    console.log(product);

    type Point2D = {x: number, y: number};
    type Point3D = {x: number, y: number, z: number};
    let a: Point2D = {x:1, y:2};
    let b: Point3D = {x:3, y:22, z:33};
    console.log(a);
    a = b;
    console.log(a);         // extra info is ignored

    // b = a;              // wrong: require z parameter which doesn't exist in Point2D

- Class:
    - in Js structure is:
    - all method of class are public by default
        class Animal{
            name;
            constructor(name){
                this.name = name;
            }

            move(distanceInMeters){
                console.log(`${this.name} moved ${distanceInMeters}m.`);
            }
        }

    - in Ts structure is:
        class Animal{
            private name: string;
            protected age: number;
            constructor(name: string, age: number){
                this.name = name;
                this.age = age
            }

            public move(distanceInMeters: number){
                console.log(`${this.name} moved ${distanceInMeters}m.`);
            }
        }

        let animal = new Animal('Cat', 20);
        animal.move(10);

        // animal.name = 'Dog';         // wrong its private
        animal.move(20);

        class Bird extends Animal{
            fly(distanceInMeters: number){
                console.log(`I'm bird my age: ${this.age} flew ${distanceInMeters}m.`);
            }
        }
        let bird = new Bird('Parrot', 10);
        bird.fly(10);

- Compiler option (tsconfig.json)
    - target: specify the target JavaScript version(ES5 or ES6, generates js file from ts in target version) inside compilerOptions inside tsconfig.json file

- any & unknown:
    let exampleAny: any;
    let exampleUnknown: unknown;

    exampleAny = 10;
    console.log(exampleAny);
    exampleAny = "world";
    console.log(exampleAny);

    exampleUnknown = 23;
    console.log(exampleUnknown);
    exampleUnknown = "Hello";
    console.log(exampleUnknown);

    // any
    exampleAny.allows.anything.you.can.imagine();
    let anyBool: boolean = exampleAny;          // allows you to assign this value to any type of variable

    // you can do this unless the type is known
    // exampleUnknown.trim();
    // let anyBool2: boolean = exampleUnknown;

    // to do trim() first check is it string
    if(typeof exampleUnknown === 'string'){
        exampleUnknown = exampleUnknown.trim();
    }

    if(typeof exampleUnknown === 'boolean'){
        let unknownSetBool: boolean = exampleUnknown;
    }

- Why any type added to the typescript in type system
 -> is to allow easy migration of JavaScript code to typescript
    eg. 
        1) simple JS code without any type (default is any type) QUICK FIX MIGRATION FROM JS TO TS
        let someLegacyVar;
        someLegacyVar = " hello   ";
        someLegacyVar = 123;
        console.log(someLegacyVar.trim());          // runtime error
        console.log(someLegacyVar.toFixed(2));

        2) // better use unknown type: HAVE TIME TO DO MORE RELIABLE RE-FACTORING OR DEALING WITH CODE THAT YOU DON'T TRUST USE unknown
        let someLegacyVar: unknown;
        someLegacyVar = 123;
        someLegacyVar = " hello   ";

        if(typeof someLegacyVar === 'string'){
            console.log(someLegacyVar.trim());
        }

        someLegacyVar = " hello   ";
        someLegacyVar = 123;
        if(typeof someLegacyVar === 'number'){
            console.log(someLegacyVar.toFixed(2));
        }

-  creating react application
    npx create-react-app .    (which creates all boiler plate code that we need to create a react application)
    npx create-react-app . --template typescript         (with typescript)

    -ts & tsx files are same the only difference is tsx file supports jsx. jsx is way of writing HTML within JavaScript

- to Build the static files present in public folder
    npm run build --verbose         (bundles them up in build folder)

- delpoying this build folder to any static file hosting server.
- to ourself the static file hosting server
    npx serve <folder name>
    npx serve build

- Type Assertion:
    It means we known better that what machine is understading.
    const load = (): unknown =>{
        return 1;
    }
    let hello = load();
    console.log(hello);

    if(typeof hello === 'string'){
        console.log((hello).trim());
    }

    // instead of doing above
    console.log((hello as string).trim());              // this will work in tsx file 
    // or same as above
    console.log((<string>hello).trim());                // this will NOT work in tsx file 
    // TypeScript will not throw an error, because you're saying:
    // Trust me, this is a string.
    // But at runtime, hello is a number (1), and calling .trim() on a number causes:

- Type Casting:
    let leet;           // default type is any
    leet = '1337'
    let num = leet as number

    console.log("num === 1337", num === 1337);
    console.log(num);
    console.log("num type: ",typeof num);

    // converting it to number
    // this is called type coersion
    let num2 = +leet;           // use + sign before variable name
    console.log("num2 === 1337", num2 === 1337);
    console.log(num2);
    console.log("num2 type: ",typeof num2);

- Modules:
    module.ts:
        export function isPalindrom(str){
            return str === str.split('').reverse().join('');
        }
    module1.ts
        import {isPalindrom} from './module';
        // or
        import * as until from './module';

        console.log("isPalindrom('racecar')? ", isPalindrom('racecar'));
        console.log("isPalindrom('car')? ", isPalindrom('car'));

        console.log("until.isPalindrom('racecar')? ",until.isPalindrom('racecar'));
        console.log("until.isPalindrom('car')? ", until.isPalindrom('car'));

- Type declaration:
    - all declaration of variable which will be provided by nodeJs is in declaration file
    - extension is <name>.d.ts
    eg.
        env.d.ts
        declare const process: any;
    
    npm i @types/node
    - if installing any external libary like express need to install their respective types
        npm i @types/express

- To pulibsh our own package
    npm publish

- To download npm i <name>
- to run ts file without
    npx tsc file_name.ts
    node file_name.js
- install this package: npm i ts-node
- npx tsx file.ts
---------------------------------------------------------------------------------------------------
#Intermediate:
---------------------------------------------------------------------------------------------------
this keyword:
    1) calling context:
        in below example the growOld is not an arrow function
        this keyword wont work with arrow and bound function
    2) lexically scoped
    class Person {
        private _age: number
        constructor (age: number){
            this._age = age;
        }
        growOld(){
            this._age++;
        }
        age(){
            return this._age;
        }
    }
    const person = new Person (0);
    person.growOld();
    const grow = person.growOld;
    grow();         // this word will be undefined here
    console. log("age: ", person.age());           // this work as expected

- Readonly modifire:
    - readonly is compile time error checking doesn't required runtime JavaScript support.
    type Point2D = {
        x: number;
        y: number
    };
    const p1: Point2D = {x: 1, y: 2};

    // variable assignment
    // p1 = {x: 3, y: 22};         // not allowed

    // property assignment
    p1.x = 3;
    p1.y = 22;          // although it should not work, but it works

    // for that use this readonly modifire
    type Point3D = {
        readonly x: number;
        readonly y: number;
        readonly z: number;
    }

    const p2: Point3D = {x: 3, y: 22, z: 33};

    // now variable assignment is not allowed
    // p2 = {x: 3, y: 22, z: 33};      // not allowed

    // along with property assigment also not allowed
    // p2.x = 37;                       // not allowed
    // p2.y = 13;                       // not allowed
    // p2.z = 30;                       // not allowed

    // but you can read them but not re-assign
    console.log(`p1: ${p1}`);           // p1: [object Object]
    console.log(`p2: ${p2}`);

    console.log(`p2: ${p2.x}`);
    console.log(`p1: ${p1.x}`);

    // to print whole data use json.stringify
    console.log(`p1: ${JSON.stringify(p1)}`);       // p1: {"x":3,"y":22}
    console.log(`p2: ${JSON.stringify(p2)}`);       // p2: {"x":3,"y":22,"z":33}

    class Animal{
        name: string;
        constructor(name: string){
            this.name = name;
        }
    }

    const sheep = new Animal('Sheep');
    console.log(sheep.name);        // allowed
    sheep.name = 'Modified';        // shouldn't be happening but value changed to avoid this use readonly modifire for name
    console.log(sheep.name);

    class Person{
        readonly name: string;
        constructor(name: string){
            this.name = name;
        }
    }

    const per1 = new Person('Vivek');
    console.log(per1.name);
    // per1.name = 'new one';          // not allowed  

- Union Types:
    Union are simply a set of types separated by | (pipe) operator
    const words: string | string[];         // this is might be one string or array of string
    const padding: number | string;

    type padding =                  // for multi-line type the first | is optional. just for code-readability
        | number
        | string

- Literal Types:
    let direction: "up" | "down" | "left" | "right";
    // direction = "one";   // not allowed
    direction = "down";   // only above mentioned values are allowed

    // or
    type CardinalDirection = "up" | "down" | "left" | "right";
    let direction1: CardinalDirection = 'up'
    console.log(direction1);

    type DiceValues = 1 | 2 | 3 | 4 | 5 | 6;
    let diceValue: DiceValues = 6;
    console.log(Math.floor(Math.random() * 6) + 1 as DiceValues);

- Type narrowing:
    class Cat {
        meow(){
            console. log ('meow');
        }
    }
    class Dog{
        bark(){
            console. log ("woof");
        }
    }
    type Animal = Cat | Dog;

    // confirming the object's type. using instanceof operator
    function speak(animal: Animal) {
        if (animal instanceof Cat){
            animal.meow();
        }
        if (animal instanceof Dog){
            animal.bark();
        }
    }

    type Square = {
        size: number;
    };

    type Rectangle = {
        width: number;
        height: number;
    };

    type Shape = Square | Rectangle;
    // here we are using the 2 different types, they are not class so we can't use instanceof operator
    // instead of we can use in operator
    function getArea(shape: Shape): number {
        if ("size" in shape) {
            return shape.size * shape.size;
        }
        if('width' in shape && 'height' in shape){
            return shape.width * shape.height;
        }
        return 0;
    }

    const c = new Cat();
    const d = new Dog();

    console.log("Square area is: ", getArea({size: 10}));
    console.log("Rectangle area is: ", getArea({width: 10, height: 20}));
    console.log("Dog: ");
    speak(d)
    console.log("Cat ");
    speak(c);

- Discriminated Unions:
    type Square1 = {
        kind:'square';
        size: number;
    };

    type Rectangle1 = {
        kind:'rectangle';
        width: number;
        height: number;
    };

    type Circle ={
        kind:'circle';
        radius: number;
    }

    type Shapes = Square1 | Rectangle1 | Circle;

    function getArea1(shape: Shapes): number {
        if (shape.kind === 'square') {
            return shape.size * shape.size;
        }else if(shape.kind === 'rectangle'){
            return shape.width * shape.height;
        }else if(shape.kind === 'circle'){
            return Math.PI * shape.radius * shape.radius;
            // return Math.PI * shape.radius ** 2;
        }else{
            throw new Error('Invalid shape');
        }
    }

    console.log("Square area is: ", getArea1({kind:'square', size: 10}));
    console.log("Rectangle area is: ", getArea1({kind:'rectangle', width: 10, height: 20}));
    console.log("Circle area is: ", getArea1({kind:'circle', radius: 10}));

    // or
    type ValidationSuccess = {
        isValid: true;
        SuccessMessage: string;
    }

    type ValidationFailure = {
        isValid: false;
        FailureMessage: string;
    }

    type ValidationResult = ValidationSuccess | ValidationFailure;

    const success: ValidationResult = {isValid: true, SuccessMessage: 'Success'};
    const failure: ValidationResult = {isValid: false, FailureMessage: 'Failure'}

    function CheckValid(input: ValidationResult){
        if(input.isValid){
            console.log(input.SuccessMessage);
        }else if(input.isValid === false){
            console.log(input.FailureMessage);
        }else{
            throw new Error('Invalid result');
        }
    }
    CheckValid(success);
    CheckValid(failure);

- class parameter properties:
    // directly declared & initialized inside constructor
    class person{
        constructor(public name: string, public age: number){}
    }
    const p1 = new person('adam', 90);
    console.log(p1.name); // adam

- strict compiler option
    - by default its set to true inside tsconfig.json file
    - to generate tsconfig.json file use npx tsc --init

- undefined & null:
    - JavaScript runtime has 2 types to indicate the absence of value
    - if something has not been initialized then return undefined
    - if something is currently unavailable then return null
eg.
    let notDefine: undefined = undefined;
    let notPresent: null = null;

    class Point{
        x:number;
        y:number;
    }

    let p: Point = new Point();
    p.x = 1;
    // p.y = 2;
    console.log(p.y);       // undefined

    function f(x: number) {
        if(x < 10) return x;
        return null;
    }

    console.log(f(11));

    console.log(null == null);      // true
    console.log(undefined == undefined);    // true

    console.log(undefined == null);     // true

    console.log(false == null);    // false
    console.log(false == undefined);    // false
    console.log(0 == null);         // false
    console.log('' == null);        // false


    function decorate(value: string | null | undefined): string {
        if(value == null) return 'NULL';
        return `--------${value.trim()}--------`;
    }

    console.log("Passing NULL: ", decorate(null));                                   // Passing NULL:  NULL
    console.log("Passing UNDEFINED: ", decorate(undefined));                         // Passing UNDEFINED:  NULL
    console.log("Passing String: ", decorate("           Hlleo           "));        // Passing String:  --------Hlleo--------

- Intersection types:
    type Point2D ={
        x:number;
        y:number;
    }

    // type Point3D ={
    //     x: number;
    //     y: number;
    //     z: number;
    // }

    type Point3D = Point2D & {
        z: number                // intersection of Point2D and Point3D
    }

    type Person = {
        name: string;
    }
    type Email = {
        email: string;
    }

    type Phone = {
        phone: string;
    }

    // function contact(details: any) {
    function contact(details: Person & Email & Phone) {                 // calling with specific type
        console.log(details.name, "\t", details.email, "\t", details.phone);
    }

    contact({ name: "Vivek", email: "vivek@me.com", phone: "1234567890" });

    // also we can do this
    type ContactDetails = Person & Phone & Email;
    // just for code-redability
    type ContactDetails2 = 
        & Person 
        & Phone
        & Email;

- Optional Modifire:
    type Person = {
        name: string;
        mail: string;
        phone?: string;             // optional modifier
    }

    const p1: Person = {
        name: 'vivek',
        mail: 'vivek@gmail.com',
        phone: '123',
    }

    const p2: Person = {
        name: 'Nikate',
        mail: 'Nikate@gmail.com',
        phone: undefined
    }

    console.log(p1, p2);
    console.log("p1.name: ", p1.name);
    console.log("p1.mail: ", p1.mail);
    console.log("p1.phone: ", p1.phone);            // if present then prints its value, else undefined

    console.log("p2.name: ", p2.name);
    console.log("p2.mail: ", p2.mail);
    console.log("p2.phone: ", p2.phone);            // if present then prints its value, else undefined

    class Point{
        x?: number;
        y?:number;
        z?: number | null;
    }

    const p = new Point();
    p.x = 1;
    p.y = 0;
    p.y = undefined;
    // p.x = null;         // null is not supported

    // to support the null we need to explicitly mention the type.
    p.z = null;
    console.log(p);

- Non null assertion:
    type Point = {
        x: number;
        y: number;
    };

    let p: Point;
    function initializePoint(){
        p = {x:1, y:2};
    }

    initializePoint();
    // if we are sure that the value must present then we can use ! non-null assertion
    console.log(p!.x);           // here its undefined but actually we defined, so we can use ! non-null assertion
    console.log(p!.y);           // here its undefined but actually we defined, so we can use ! non-null assertion

    type Person = {
        name: string;
        email?: string | null;
    }
    const p1: Person = {name:'v', email:'v@v.com'}
    const p2: Person = {name:'G'};

    function ensureContactable(p: Person){
        if(p.email == undefined) throw new Error(`Person ${p1.name} is not contactable`);
    }

    function SendOutMail(p: Person){
        ensureContactable(p);
        console.log(`Sending mail to ${p!.email}`);
        // The ! after p tells TypeScript: "I am sure that p is not null or undefined."
        console.log(`Sending mail to ${p.email!}`);
        // The ! after email tells TypeScript: "I am sure that email is not null or undefined."
    }

    SendOutMail(p1);
    SendOutMail(p2);            // Person v is not contactable

- Interfaces:
    type Point2D = {
        x:number;
        y:number;
    }

    type Point3D = Point2D & {
        z: number                // intersection of Point2D and Point3D
    }

    export const p1: Point3D = {
        x:1,
        y:2,
        z:3
    }

    // in same way as type we can use interfaces, difference is '=' operator & extends keyword
    interface Point2D1 {
        x: number;
        y: number;
    }

    interface Point3D1 extends Point2D1 {
        z: number;
    }

    export const p2: Point3D1 = {
        x:1,
        y:2,
        z:3
    }

- inface declaration merging:
    - this doesn't work with type alias
    export interface Request {
        body: any;
    }
    export interface Request {
        json: any;
    }

    function handleRequest(req: Request) {
        console.log(req.body);
        console.log(req.json);
    }
    handleRequest({ body: 1, json: 2 });

- Type & interface:
    Types supports:                 Interfaces supports:
    Unions                           Declaration Merging
    Intersections (&)                Familiarity (extends)
    Primitives
    Shorthand Functions
    Advanced Tune Functions

- Type: never
---------------------------------------------------------------------------------------------------
#Advance:
---------------------------------------------------------------------------------------------------
- Implements keyword:
    

---------------------------------------------------------------------------------------------------