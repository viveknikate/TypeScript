---------------------------------------------------------------------------------------------------
#Basics:
---------------------------------------------------------------------------------------------------
- https://github.com/basarat/typescript-for-professionals
- Check versions
    node --versions
    node -v

    npm --versions
    npm -v

    npx --versions
    npx -v

- Create new project
    mkdir intro
    cd intro
    npm init -y

- npx tsc --init --rootdir src --outdir lib

- Primitive Types;
    1) boolean
    2) number
    3) string
    4) undefined    (value is not defined)
    5) null     (value is not present)
    6) Symbol
    7) bigint
eg.
    let isPresent: boolean = false;
    let magic: number = 20
    let notDefine: undefined = undefined;
    let notPresent: null = null;
    // let penta: Symbol = Symbol('star');
    // let bigg: bigint = 24n;

    console.log(isPresent);
    console.log(magic);
    console.log(notDefine);
    console.log(notPresent);
    // console.log(penta);
    // console.log(bigg);

- Arrays:
    let regex: RegExp = new RegExp('ab+c');
    let arr1: Array<number> = [1,2,3];
    let arr2: number[] = [1,2,3,4,5,6,7,8,9,10];
    // let set: Set<number> = new Set([1,2,3]);

    console.log(regex);
    console.log(arr1);
    console.log(arr2);
    // console.log(set);

- Tuple:
    let t: [number, number] = [1,2];
    console.log(t);

    t = [10, 50];
    console.log(t);

    // wrong
    // t = [1];                // must have 2 elements
    // t = [1,2,3];

    // t = ['c', 2];       // must have both element of type number

- Type Alias:
    type Point = {x: number, y: number};

    let p1: Point = {x:1, y:2};
    let p2: Point = {x:3, y:22};

    // const p3: Point = {xx:2, y:3};  // wrong
    const p4: Point = {x:2, y:3};
    // p4 = {x:20, y:30};              // const cannot be re-assigned but
    p4.x = 100;
    p4.y = 200;

    console.log(p1);
    console.log(p2);
    console.log(p4);

- Function:
    function add(a: number, b: number): number{
        return a+b;
    }

    function log(message: string): void{
        console.log(message);
    }

    function sum(...values: number[]): number{
        return values.reduce((a,b)=> {
            return a+b
        });
    }

    console.log(add(1,2));
    log("hello");
    console.log(sum(1,2,3,4));
    console.log(sum(1,23));

    // first class function
    type ADD = (a: number, b: number) => number;

    let add1: ADD = (a,b) => {
        return a+b;
    }
    let add2: ADD = (a,b)=> {
        return a+b;
    }
    console.log(add1(10,22));
    console.log(add2(1,2));

- Structural:
    type User = { id: string};
    type Product = { id: string};

    let user: User = {id: '1'};
    let product: Product = {id: '2'};

    // this is ok, both have same structure
    console.log(product);
    product = user
    console.log(product);

    type Point2D = {x: number, y: number};
    type Point3D = {x: number, y: number, z: number};
    let a: Point2D = {x:1, y:2};
    let b: Point3D = {x:3, y:22, z:33};
    console.log(a);
    a = b;
    console.log(a);         // extra info is ignored

    // b = a;              // wrong: require z parameter which doesn't exist in Point2D

- Class:
    - in Js structure is:
    - all method of class are public by default
        class Animal{
            name;
            constructor(name){
                this.name = name;
            }

            move(distanceInMeters){
                console.log(`${this.name} moved ${distanceInMeters}m.`);
            }
        }

    - in Ts structure is:
        class Animal{
            private name: string;
            protected age: number;
            constructor(name: string, age: number){
                this.name = name;
                this.age = age
            }

            public move(distanceInMeters: number){
                console.log(`${this.name} moved ${distanceInMeters}m.`);
            }
        }

        let animal = new Animal('Cat', 20);
        animal.move(10);

        // animal.name = 'Dog';         // wrong its private
        animal.move(20);

        class Bird extends Animal{
            fly(distanceInMeters: number){
                console.log(`I'm bird my age: ${this.age} flew ${distanceInMeters}m.`);
            }
        }
        let bird = new Bird('Parrot', 10);
        bird.fly(10);

- Compiler option (tsconfig.json)
    - target: specify the target JavaScript version(ES5 or ES6, generates js file from ts in target version) inside compilerOptions inside tsconfig.json file

- any & unknown:
    let exampleAny: any;
    let exampleUnknown: unknown;

    exampleAny = 10;
    console.log(exampleAny);
    exampleAny = "world";
    console.log(exampleAny);

    exampleUnknown = 23;
    console.log(exampleUnknown);
    exampleUnknown = "Hello";
    console.log(exampleUnknown);

    // any
    exampleAny.allows.anything.you.can.imagine();
    let anyBool: boolean = exampleAny;          // allows you to assign this value to any type of variable

    // you can do this unless the type is known
    // exampleUnknown.trim();
    // let anyBool2: boolean = exampleUnknown;

    // to do trim() first check is it string
    if(typeof exampleUnknown === 'string'){
        exampleUnknown = exampleUnknown.trim();
    }

    if(typeof exampleUnknown === 'boolean'){
        let unknownSetBool: boolean = exampleUnknown;
    }

- Why any type added to the typescript in type system
 -> is to allow easy migration of JavaScript code to typescript
    eg. 
        1) simple JS code without any type (default is any type) QUICK FIX MIGRATION FROM JS TO TS
        let someLegacyVar;
        someLegacyVar = " hello   ";
        someLegacyVar = 123;
        console.log(someLegacyVar.trim());          // runtime error
        console.log(someLegacyVar.toFixed(2));

        2) // better use unknown type: HAVE TIME TO DO MORE RELIABLE RE-FACTORING OR DEALING WITH CODE THAT YOU DON'T TRUST USE unknown
        let someLegacyVar: unknown;
        someLegacyVar = 123;
        someLegacyVar = " hello   ";

        if(typeof someLegacyVar === 'string'){
            console.log(someLegacyVar.trim());
        }

        someLegacyVar = " hello   ";
        someLegacyVar = 123;
        if(typeof someLegacyVar === 'number'){
            console.log(someLegacyVar.toFixed(2));
        }

-  creating react application
    npx create-react-app .    (which creates all boiler plate code that we need to create a react application)
    npx create-react-app . --template typescript         (with typescript)

    -ts & tsx files are same the only difference is tsx file supports jsx. jsx is way of writing HTML within JavaScript

- to Build the static files present in public folder
    npm run build --verbose         (bundles them up in build folder)

- delpoying this build folder to any static file hosting server.
- to ourself the static file hosting server
    npx serve <folder name>
    npx serve build

- Type Assertion:
    It means we known better that what machine is understading.
    const load = (): unknown =>{
        return 1;
    }
    let hello = load();
    console.log(hello);

    if(typeof hello === 'string'){
        console.log((hello).trim());
    }

    // instead of doing above
    console.log((hello as string).trim());              // this will work in tsx file 
    // or same as above
    console.log((<string>hello).trim());                // this will NOT work in tsx file 
    // TypeScript will not throw an error, because you're saying:
    // Trust me, this is a string.
    // But at runtime, hello is a number (1), and calling .trim() on a number causes:

- Type Casting:
    let leet;           // default type is any
    leet = '1337'
    let num = leet as number

    console.log("num === 1337", num === 1337);
    console.log(num);
    console.log("num type: ",typeof num);

    // converting it to number
    // this is called type coersion
    let num2 = +leet;           // use + sign before variable name
    console.log("num2 === 1337", num2 === 1337);
    console.log(num2);
    console.log("num2 type: ",typeof num2);

- Modules:
    module.ts:
        export function isPalindrom(str){
            return str === str.split('').reverse().join('');
        }
    module1.ts
        import {isPalindrom} from './module';
        // or
        import * as until from './module';

        console.log("isPalindrom('racecar')? ", isPalindrom('racecar'));
        console.log("isPalindrom('car')? ", isPalindrom('car'));

        console.log("until.isPalindrom('racecar')? ",until.isPalindrom('racecar'));
        console.log("until.isPalindrom('car')? ", until.isPalindrom('car'));

- Type declaration:
    - all declaration of variable which will be provided by nodeJs is in declaration file
    - extension is <name>.d.ts
    eg.
        env.d.ts
        declare const process: any;
    
    npm i @types/node
    - if installing any external libary like express need to install their respective types
        npm i @types/express

- To pulibsh our own package
    npm publish

- To download npm i <name>
- to run ts file without
    npx tsc file_name.ts
    node file_name.js
- install this package: npm i ts-node
- npx tsx file.ts
---------------------------------------------------------------------------------------------------
#Intermediate:
---------------------------------------------------------------------------------------------------
this keyword:
    1) calling context:
        in below example the growOld is not an arrow function
        this keyword wont work with arrow and bound function
    2) lexically scoped
    class Person {
        private _age: number
        constructor (age: number){
            this._age = age;
        }
        growOld(){
            this._age++;
        }
        age(){
            return this._age;
        }
    }
    const person = new Person (0);
    person.growOld();
    const grow = person.growOld;
    grow();         // this word will be undefined here
    console. log("age: ", person.age());           // this work as expected

- Readonly modifire:
    - readonly is compile time error checking doesn't required runtime JavaScript support.
    type Point2D = {
        x: number;
        y: number
    };
    const p1: Point2D = {x: 1, y: 2};

    // variable assignment
    // p1 = {x: 3, y: 22};         // not allowed

    // property assignment
    p1.x = 3;
    p1.y = 22;          // although it should not work, but it works

    // for that use this readonly modifire
    type Point3D = {
        readonly x: number;
        readonly y: number;
        readonly z: number;
    }

    const p2: Point3D = {x: 3, y: 22, z: 33};

    // now variable assignment is not allowed
    // p2 = {x: 3, y: 22, z: 33};      // not allowed

    // along with property assigment also not allowed
    // p2.x = 37;                       // not allowed
    // p2.y = 13;                       // not allowed
    // p2.z = 30;                       // not allowed

    // but you can read them but not re-assign
    console.log(`p1: ${p1}`);           // p1: [object Object]
    console.log(`p2: ${p2}`);

    console.log(`p2: ${p2.x}`);
    console.log(`p1: ${p1.x}`);

    // to print whole data use json.stringify
    console.log(`p1: ${JSON.stringify(p1)}`);       // p1: {"x":3,"y":22}
    console.log(`p2: ${JSON.stringify(p2)}`);       // p2: {"x":3,"y":22,"z":33}

    class Animal{
        name: string;
        constructor(name: string){
            this.name = name;
        }
    }

    const sheep = new Animal('Sheep');
    console.log(sheep.name);        // allowed
    sheep.name = 'Modified';        // shouldn't be happening but value changed to avoid this use readonly modifire for name
    console.log(sheep.name);

    class Person{
        readonly name: string;
        constructor(name: string){
            this.name = name;
        }
    }

    const per1 = new Person('Vivek');
    console.log(per1.name);
    // per1.name = 'new one';          // not allowed  

- Union Types:
    Union are simply a set of types separated by | (pipe) operator
    const words: string | string[];         // this is might be one string or array of string
    const padding: number | string;

    type padding =                  // for multi-line type the first | is optional. just for code-readability
        | number
        | string

- Literal Types:
    let direction: "up" | "down" | "left" | "right";
    // direction = "one";   // not allowed
    direction = "down";   // only above mentioned values are allowed

    // or
    type CardinalDirection = "up" | "down" | "left" | "right";
    let direction1: CardinalDirection = 'up'
    console.log(direction1);

    type DiceValues = 1 | 2 | 3 | 4 | 5 | 6;
    let diceValue: DiceValues = 6;
    console.log(Math.floor(Math.random() * 6) + 1 as DiceValues);

- Type narrowing:
    class Cat {
        meow(){
            console. log ('meow');
        }
    }
    class Dog{
        bark(){
            console. log ("woof");
        }
    }
    type Animal = Cat | Dog;

    // confirming the object's type. using instanceof operator
    function speak(animal: Animal) {
        if (animal instanceof Cat){
            animal.meow();
        }
        if (animal instanceof Dog){
            animal.bark();
        }
    }

    type Square = {
        size: number;
    };

    type Rectangle = {
        width: number;
        height: number;
    };

    type Shape = Square | Rectangle;
    // here we are using the 2 different types, they are not class so we can't use instanceof operator
    // instead of we can use in operator
    function getArea(shape: Shape): number {
        if ("size" in shape) {
            return shape.size * shape.size;
        }
        if('width' in shape && 'height' in shape){
            return shape.width * shape.height;
        }
        return 0;
    }

    const c = new Cat();
    const d = new Dog();

    console.log("Square area is: ", getArea({size: 10}));
    console.log("Rectangle area is: ", getArea({width: 10, height: 20}));
    console.log("Dog: ");
    speak(d)
    console.log("Cat ");
    speak(c);

- Discriminated Unions:
    type Square1 = {
        kind:'square';
        size: number;
    };

    type Rectangle1 = {
        kind:'rectangle';
        width: number;
        height: number;
    };

    type Circle ={
        kind:'circle';
        radius: number;
    }

    type Shapes = Square1 | Rectangle1 | Circle;

    function getArea1(shape: Shapes): number {
        if (shape.kind === 'square') {
            return shape.size * shape.size;
        }else if(shape.kind === 'rectangle'){
            return shape.width * shape.height;
        }else if(shape.kind === 'circle'){
            return Math.PI * shape.radius * shape.radius;
            // return Math.PI * shape.radius ** 2;
        }else{
            throw new Error('Invalid shape');
        }
    }

    console.log("Square area is: ", getArea1({kind:'square', size: 10}));
    console.log("Rectangle area is: ", getArea1({kind:'rectangle', width: 10, height: 20}));
    console.log("Circle area is: ", getArea1({kind:'circle', radius: 10}));

    // or
    type ValidationSuccess = {
        isValid: true;
        SuccessMessage: string;
    }

    type ValidationFailure = {
        isValid: false;
        FailureMessage: string;
    }

    type ValidationResult = ValidationSuccess | ValidationFailure;

    const success: ValidationResult = {isValid: true, SuccessMessage: 'Success'};
    const failure: ValidationResult = {isValid: false, FailureMessage: 'Failure'}

    function CheckValid(input: ValidationResult){
        if(input.isValid){
            console.log(input.SuccessMessage);
        }else if(input.isValid === false){
            console.log(input.FailureMessage);
        }else{
            throw new Error('Invalid result');
        }
    }
    CheckValid(success);
    CheckValid(failure);

- class parameter properties:
    // directly declared & initialized inside constructor
    class person{
        constructor(public name: string, public age: number){}
    }
    const p1 = new person('adam', 90);
    console.log(p1.name); // adam

- strict compiler option
    - by default its set to true inside tsconfig.json file
    - to generate tsconfig.json file use npx tsc --init

- undefined & null:
    - JavaScript runtime has 2 types to indicate the absence of value
    - if something has not been initialized then return undefined
    - if something is currently unavailable then return null
eg.
    let notDefine: undefined = undefined;
    let notPresent: null = null;

    class Point{
        x:number;
        y:number;
    }

    let p: Point = new Point();
    p.x = 1;
    // p.y = 2;
    console.log(p.y);       // undefined

    function f(x: number) {
        if(x < 10) return x;
        return null;
    }

    console.log(f(11));

    console.log(null == null);      // true
    console.log(undefined == undefined);    // true

    console.log(undefined == null);     // true

    console.log(false == null);    // false
    console.log(false == undefined);    // false
    console.log(0 == null);         // false
    console.log('' == null);        // false


    function decorate(value: string | null | undefined): string {
        if(value == null) return 'NULL';
        return `--------${value.trim()}--------`;
    }

    console.log("Passing NULL: ", decorate(null));                                   // Passing NULL:  NULL
    console.log("Passing UNDEFINED: ", decorate(undefined));                         // Passing UNDEFINED:  NULL
    console.log("Passing String: ", decorate("           Hlleo           "));        // Passing String:  --------Hlleo--------

- Intersection types:
    type Point2D ={
        x:number;
        y:number;
    }

    // type Point3D ={
    //     x: number;
    //     y: number;
    //     z: number;
    // }

    type Point3D = Point2D & {
        z: number                // intersection of Point2D and Point3D
    }

    type Person = {
        name: string;
    }
    type Email = {
        email: string;
    }

    type Phone = {
        phone: string;
    }

    // function contact(details: any) {
    function contact(details: Person & Email & Phone) {                 // calling with specific type
        console.log(details.name, "\t", details.email, "\t", details.phone);
    }

    contact({ name: "Vivek", email: "vivek@me.com", phone: "1234567890" });

    // also we can do this
    type ContactDetails = Person & Phone & Email;
    // just for code-redability
    type ContactDetails2 = 
        & Person 
        & Phone
        & Email;

- Optional Modifire:
    type Person = {
        name: string;
        mail: string;
        phone?: string;             // optional modifier
    }

    const p1: Person = {
        name: 'vivek',
        mail: 'vivek@gmail.com',
        phone: '123',
    }

    const p2: Person = {
        name: 'Nikate',
        mail: 'Nikate@gmail.com',
        phone: undefined
    }

    console.log(p1, p2);
    console.log("p1.name: ", p1.name);
    console.log("p1.mail: ", p1.mail);
    console.log("p1.phone: ", p1.phone);            // if present then prints its value, else undefined

    console.log("p2.name: ", p2.name);
    console.log("p2.mail: ", p2.mail);
    console.log("p2.phone: ", p2.phone);            // if present then prints its value, else undefined

    class Point{
        x?: number;
        y?:number;
        z?: number | null;
    }

    const p = new Point();
    p.x = 1;
    p.y = 0;
    p.y = undefined;
    // p.x = null;         // null is not supported

    // to support the null we need to explicitly mention the type.
    p.z = null;
    console.log(p);

- Non null assertion:
    type Point = {
        x: number;
        y: number;
    };

    let p: Point;
    function initializePoint(){
        p = {x:1, y:2};
    }

    initializePoint();
    // if we are sure that the value must present then we can use ! non-null assertion
    console.log(p!.x);           // here its undefined but actually we defined, so we can use ! non-null assertion
    console.log(p!.y);           // here its undefined but actually we defined, so we can use ! non-null assertion

    type Person = {
        name: string;
        email?: string | null;
    }
    const p1: Person = {name:'v', email:'v@v.com'}
    const p2: Person = {name:'G'};

    function ensureContactable(p: Person){
        if(p.email == undefined) throw new Error(`Person ${p1.name} is not contactable`);
    }

    function SendOutMail(p: Person){
        ensureContactable(p);
        console.log(`Sending mail to ${p!.email}`);
        // The ! after p tells TypeScript: "I am sure that p is not null or undefined."
        console.log(`Sending mail to ${p.email!}`);
        // The ! after email tells TypeScript: "I am sure that email is not null or undefined."
    }

    SendOutMail(p1);
    SendOutMail(p2);            // Person v is not contactable

- Interfaces:
    type Point2D = {
        x:number;
        y:number;
    }

    type Point3D = Point2D & {
        z: number                // intersection of Point2D and Point3D
    }

    export const p1: Point3D = {
        x:1,
        y:2,
        z:3
    }

    // in same way as type we can use interfaces, difference is '=' operator & extends keyword
    interface Point2D1 {
        x: number;
        y: number;
    }

    interface Point3D1 extends Point2D1 {
        z: number;
    }

    export const p2: Point3D1 = {
        x:1,
        y:2,
        z:3
    }

- inface declaration merging:
    - this doesn't work with type alias
    export interface Request {
        body: any;
    }
    export interface Request {
        json: any;
    }

    function handleRequest(req: Request) {
        console.log(req.body);
        console.log(req.json);
    }
    handleRequest({ body: 1, json: 2 });

- Type & interface:
    Types supports:                 Interfaces supports:
    Unions                           Declaration Merging
    Intersections (&)                Familiarity (extends)
    Primitives
    Shorthand Functions
    Advanced Tune Functions

- Type: never
---------------------------------------------------------------------------------------------------
#Advance:
---------------------------------------------------------------------------------------------------
- Implements keyword:
    type animal = {
        name: string;
        voice(): void;
    }

    class Cat implements animal{
        constructor(public name: string){}
        voice(): void {
            console.log('Meow');
        }
    }

    class Duck implements animal{
        constructor(public name: string){}
        voice(): void{
            console.log('quack');
        }
    }
    const c = new Cat('Cat');
    const d = new Duck('Duck');
    console.log(c.name);
    console.log(d.name);

    d.voice();
    c.voice();

- Definitely Assignment Assertion:
    let dice: number;
    function rollDice(){
        dice = Math.floor(Math.random()*6)+1;
    }

    rollDice()
    console.log("Value is: ", dice!);        // here we are getting the error so using !

    // we are logging again so that we can see the value
    rollDice()
    console.log("Value is: ", dice!);

    // again we are getting the same erorr
    // to overcome above issue we can use ! when we declare the variable

    // we are sure that before using that dice2 value it must be defined ( we'll for sure assign some value to it)
    let dice2!: number;
    function rollDice2(){
        dice = Math.floor(Math.random()*6)+1;
    }

    rollDice()
    console.log("Value is: ", dice2);        // here we are getting the error so using !

    // we are logging again so that we can see the value
    rollDice()
    console.log("Value is: ", dice2);

    class Point{
        x!: number;
        y!: number;
        constructor(){
            this.moveRandom();
        }
        moveRandom(){
            this.x = Math.random();
            this.y = Math.random();
        }
    };

- User Defined Type guards:
    type Square ={
        size: number;
    };

    type Rectangle = {
        width: number;
        height: number;
    };
    type Shape = Square | Rectangle;

    const isSquare = (shape: Shape): shape is Square => 'size' in shape         // if its one line code, then no need to use return

    // function isSquare (s1: Shape): s1 is Square {
    //     return 'size' in s1;
    // }

    const isRectangle = (shape: Shape): shape is Rectangle => 'width' in shape;

    function getArea(shape: Shape) : number {
        if(isSquare(shape)) return shape.size * shape.size;
        if(isRectangle(shape)) return shape.height * shape.width;
        return 0;
    }

    console.log(getArea({size: 10}));
    console.log(getArea({width: 10, height: 20}));

- Assertion Function:
    - Assertion function used while developing & testing
    type Person = {
        name: string;
        DOB?: Date;
    };

    function loadPerson(): Person | null{
        // return {name:'sdf', DOB: new Date()};
        return null;
    }
    const mayBePerson = loadPerson();
    function checkAssert(isPossible: unknown, message: string): asserts isPossible{
        if(!isPossible) throw new Error(message);
    }

    checkAssert(mayBePerson != null, "unable to fetch data")
    // here before accessing name we need to check for null
    console.log("Name is: ", mayBePerson.name);

    function CheckDate(dateValue: unknown, message: string): asserts dateValue is Date{
        if(!(dateValue instanceof Date)) throw new TypeError(message);
    }

    CheckDate(mayBePerson.DOB, 'not Date');
    console.log("DOB is: ", mayBePerson.DOB.toISOString());

- Function Overloading: read online

- Function:
    type Add = {
        (a: number, b: number): number,
        (a: number, b: number, c: number): number,
        debugName?: string,
    };

    const add: Add = (a: number, b: number) => a + b;
    add.debugName = 'Addition with 2 values'
    console.log(add(1, 2));
    console.log(add.debugName);

    const add2: Add = (a: number, b: number, c?: number) => a + b + (c != null ? c : 0);
    add2.debugName = 'With 3'
    console.log(add2(1, 2, 3));
    console.log(add2.debugName);

    type PointCreator = {
        // class
        new (x:number, y:number) : {x: number, y: number}
        // class - 2
        new (x:number, y:number, z:number) : {x: number, y: number, z:number},

        // fun-1
        (x:number, y:number) : number;
        // fun-2
        (x:number, y:number, z:number) : number;
        // attribute
        debugName?: string
    }

- Abstract class:
    - we just declare the things here.
    abstract class CommandLine {
        abstract command(): string;                 // this is just function declaration.
        execute(){
            console.log('executing command', this.command());
        }
    }

    // we can't create the object of abstract class as it only contains the declaration of function not their actually value
    //  we can create the object of class which is extending the abstract class. like below

    class git1 extends CommandLine {
        command(): string {
            return 'git1';
        }
    }

    class git2 extends CommandLine{
        command(): string {
            return "git2";
        }
    }

    new git1().execute();
    new git2().execute();

    // can't 
    // new CommandLine().execute();

- index signature:
    const str = {
        hello: 'world',
    };
    console.log(str.hello);
    console.log(str['hello']);

    type Perosn = {
        name: string;
        age: number;
        email: string;
    }

    type PersonDictionary = {
        [username: string]: Perosn;
    }

    const user1: PersonDictionary = {
        Vivek:{
            name: 'Vivek',
            age: 30,
            email: 'vivek@me.com',
        }
    }

    user1['Mahesh'] = {
        name:'Mahesh',
        email: 'mahesh@me.com',
        age: 25,
    }

    console.log(user1);
    console.log(user1.Vivek);
    console.log(user1['Vivek']);
    console.log(user1['Mahesh']);
    console.log(user1.tt);          // if not defined before it comes as undefined so use ?
    console.log(user1.tt ? user1.tt : 'not defined');

- Readonly:
    function reverseSorted(input: readonly number[]): number[] {
        // return input.sort().reverse();  // this will change the original array
        return input.slice().sort().reverse();  // slice is to create the copy of original array
    }
    const numbers = [1, 2, 3, 4, 5];
    const res = reverseSorted(numbers);
    console.log(res);
    console.log(numbers);

    type Neat = readonly number[];
    type Long = ReadonlyArray<number>;

    type Point = readonly [x: number, y: number];

    const p1: Point = [0, 0]
    function move(p: Point, x: number, y: number) {
        return [p[0] + x, p[1] + y];                // this will not mutate the original tuple
        // p[0] += x;
        // p[1] += y;
        // return p;
    }
    const p2 = move(p1, 10, 10);
    console.log(p1);                // it shouldn't be changing so make the point readonly
    console.log(p2);

- Double Assertion:
    type Point2D = {
        x: number;
        y: number;
    };

    type Point3D = {
        x: number;
        y: number;
        z: number;
    }

    let p1: Point2D = {x: 1, y: 2};
    let p2: Point3D = {x: 1, y: 2, z: 3};

    // so we can, coz all things are present there in p2 required for p1
    p1 = p2;

    // but p2 != p1, doesn't contains last value z in p1 required for p2
    // p2 = p1; // getting error

    // we can say trust me its safe
    p2 = p1 as Point3D

    type person = {
        name: string;
        email: string;
    }

    let a1: person = {name: 'v', email: 'v@v.com'}

    // here 
    // a1 = p1 as person   // single assertion is not working coz there is no common property between a1 and p1
    a1 = p1 as unknown as person;       // double assertion, error gone
    // we can assign any variable type to unknown & unknown can be asserted to anything, use with Caution 

- Const Assertion:
    - const declaration for string or number in JavaScript are immutable
    - but object and array are mutable even if they are declared as const
    - to behave the object as const we can declare the type for them. or other way ' as const ' at the end of object as assertion
    eg.
        const name1 = "Vivek";
        console.log(name1);
        // name = "Nikate";            // not allowed

        const num = 123;
        console.log(num);
        // num = 456;                  // not allowed

        const dev = {
            name: 'Vivek',
            age: 21,
        }

        console.log(dev);
        // dev = {                         // direct assignment not allowed, but
        //     name: 'Nikate',
        //     age: 22,
        // }

        // this is allowed, but it shouldn't.
        dev.name = 'Nikate';
        dev.age = 22;

        // to avoid above use const assertion
        const dev1 = {
            name: 'Pointer',
            age: 1001,
        } as const;

        console.log(dev1);
        // dev1.name = 'Nikate';           // not allowed
        // dev1.age = 2002;                  // not allowed

        function layout(setting: {
            align: 'left' | 'right' | 'center';
            padding: number;
        }){
            console.log(setting);
        }

        const example = {
            align: 'left' as const,      // or use here
            padding: 20,
        } // as const

        layout(example);            // getting error if we remove as const assertion from example variable

        layout({
            align:"center",
            padding: 10,
        })

- Generic constraints:

- Uncertainity:
    let example: string | null = 'hello';
    if(example != null){
        let example1: string = example.toUpperCase();
        ['a', 'b', 'c'].forEach((item) => {
            let example2: string = item + example.toUpperCase();            // to avoid this
            console.log(example2);
        });

        ['a', 'b', 'c'].forEach((item) => {
            let example2: string = item + example1.toUpperCase();            // store variable in local scope example1
            console.log(example2);
        })
    }
---------------------------------------------------------------------------------------------------
#Expert:
---------------------------------------------------------------------------------------------------
- Type of type operator:
    const center = {
        x: 10,
        y: 20,
        z: 30,
    };

    type Point = typeof center;

    const point1: Point = {
        x: 1,
        y: 2,
        z: 3,
    };

    const response = {
        "name" : "Vivek",
        "email" : "vivek@me.com",
        "phone" : "1234567890",
        "age" : 20,
    }

    type responseType = typeof response;

    function handle(res: responseType){
        console.log(res.name, " ", res.email);
    }

- LookupTypes:
    type SubmitRequest = {
        name: string;
        email: string;
        age: number;
        id: number;
        address: {
            street: string;
            city: string[];
        }
    }

    const addre1: SubmitRequest['address'];
    const citiesLived = SubmitRequest['address']['city'][0];            // retriving first city

- keyof Operator:
    type Person = {
        name: string;
        email: string;
        age: string;
        location: string;
    };

    function logDetails(obj: Person, key: string){
        const value = obj[key];
        console.log(`The value of ${key} is: ${value}`);
    }

    logDetails({ name: 'Vivek', email: 'vivek@gmail', age: '22', location: 'Delhi' }, 'one');           // undefined

    function logDetails2(obj: Person, key: 'name' | 'email' | 'age' | 'location'){
        const value = obj[key];
        console.log(`The value of ${key} is: ${value}`);
    }

    // logDetails2({ name: 'Vivek', email: 'vivek@gmail', age: '22', location: 'Delhi' }, 'two');           // this will not allowed

    // we reduce the repetitive work here using keyof operator

    type PersonKeys = keyof Person;

    function logDetails3(obj: any, key: PersonKeys){
        const value = obj[key];
        console.log(`The value of ${key} is: ${value}`);
    }

    // logDetails3({ name: 'Vivek', email: 'vivek@gmail', age: '22', location: 'Delhi' }, 'four');     // not allowed
    logDetails3({ name: 'Vivek', email: 'vivek@gmail', age: '22', location: 'Delhi' }, 'name');     // not allowed

    // Generic function creation:
    function logGet<Obj, Key extends keyof Obj>(obj: Obj, key: Key): Obj[Key] {
        return obj[key];
    } 

- conditional Types:
    // we can create a our own custom types also
    export type TypeName<T> = 
        T extends number ? 'number' :
        T extends string ? 'string' :
        T extends undefined ? 'undefined' :
        T extends boolean ? 'boolean' :
        T extends symbol ? 'symbol' :
        T extends bigint ? 'bigint' :
        T extends Function ? 'Function' :
        T extends null ? 'null' :
        'object';


    function typeName<T>(t: T): TypeName<T> {
        if(t === null) return 'null' as TypeName<T>;            // to avoid null as object, now null considered as null
        return typeof t as TypeName<T>;
    }

    console.log(typeName(1));
    console.log(typeName('1'));
    console.log(typeName(true));
    console.log(typeName(undefined));
    console.log(typeName(null));                // null is cosidered as object
    console.log(typeName({}));

- infer:
    export function createPerson(first: string, last: string){
        return {
            name: first,
            surname: last,
            fullname: `${first} ${last}`,
        }
    };

    type returnType<T> = T extends (...args: any) => infer R
            ? R
            : never;

    type Perons = returnType<typeof createPerson> 
    // using our own returnType
    function logDetails(obj: returnType<typeof createPerson>){
        console.log(obj.name, obj.surname, obj.fullname);
    }
    
    // Built-in ReturnType
    function logDetails(obj: ReturnType<typeof createPerson>){
        console.log(obj.name, obj.surname, obj.fullname);
    }

    logDetails(createPerson('Vivek', 'Nikate'));

- mapped Types:
    type Point = {
        x: number;
        y: number;
        z: number;
    };

    const center: Point = {
        x:10,
        y:20,
        z:30,
    };

    // here I am able to change the values of center property
    center.x = 100;         // but this should not happen to avoid this

    type ReadonlyPoint = {
        readonly x: number;
        readonly y: number;
        readonly z: number;
    };

    // we can use above property, but code repetition.
    // DRY (Don't Repeat Yourself)
    type ReadonlyPointMapped = {
        readonly [K in 'x'|'y'|'z']: number;
        // readonly [K in keyof Point]: Point[K];
    }

    const center2: ReadonlyPointMapped = {
        x:10,
        y:20,
        z:30,
    }

    // center2.x = 100;         // this is not allowed now.

    // creating generic type

    // This Generic is already there in Typescript
    type ReadonlyPointGeneric<T> = {
        readonly [K in keyof T]: T[K];
    }

    const center3: ReadonlyPointGeneric<Point> ={
        x:10,
        y:20,
        z:30,
    }
    // center3.x = 100;        // not allowed

    const center4: Readonly<Point> ={
        x:10,
        y:20,
        z:30,
    }

    console.log(center4.x);
    // center4.z = 12;     // not allowed

- mapped modifire:
    type Point = {
        readonly x: number;
        y?: number;
    }

    type Mapped<T> = {
        // readonly [K in keyof T]: T[K];          
        // -readonly [K in keyof T]: T[K];              // - sign at start will remove readonly modifire if its there in type
        // +readonly [K in keyof T]: T[K];              // + sign at start is just for readability
        // +readonly [K in keyof T]?: T[K];              // ? sign at end to treat all variable as optional
        // +readonly [K in keyof T]-?: T[K];              // - sign before ? is to remove all optional sign from type treat as mandatory 
    }

    type T1 = Mapped<Point>

- Template Literal:
    string with single quote 'asdfwer'
    string with double quote "asdfwer"
    string with template literal `asdfwer ${value}`
    eg.
        type CSSValue = 
        | number
        | string
        | `${number}px`
        | `${number}em`
        | `${number}rem;`


        // create type combination of size & color
        // size = small or medium or large
        // color = primary or secondary

        type Size = 'small' | 'medium' | 'large';
        type Color = 'primary' | 'secondary';

        type CombineType = `${Size}-${Color}`;

        function Check(input: CombineType){
            console.log(input);
        }

        Check('small-secondary')
        Check('small-primary')
        Check('medium-primary');
        // Check('werelwj')            // ERRor
---------------------------------------------------------------------------------------------------
#Super:
---------------------------------------------------------------------------------------------------
- Create a type which makes all properties in Type T as optional:
    type Point = {
        x: number;
        y: number;
        z: number;
        name: string;
        FavColor: 'Red' | 'Green' | 'Blue';
    }

    let p1: Point;                  // all mandatory property    

    type Partials<T> = {
        [K in keyof T]?: T[K];
    }

    type Optional = Partials<Point>;            // all optional property
    let p2: Optional;

- Required<T>:
    type circleConfig = {
        color?: string;
        radius?: number;
    }

    class circle {
        private config: Required<circleConfig>;         // here we are making the config as required
        constructor(config: circleConfig) {
            this.config = {
                color: config.color ?? 'Black',
                radius: config.radius ?? 100,
            };
        }
        draw(){
            console.log(`My Color is: ${this.config.color} and radius is: ${this.config.radius}`);
        }
    }

    const c1 = new circle({color: 'Red'});
    const c2 = new circle({radius:56});

    console.log("C1: ", c1);
    console.log("C2: ", c2);

- Readonly<T>:
    type Point = {
        x: number;
        y: number;
    };

    const center: Readonly<Point> = {
        x: 12,
        y: 29
    }

    console.log(center);
    // values are read-only, can't be changed
    // center.x = 45;          // not allowed

- Record<K,V>:
    type Person = Record<string, {name: string, role: string}>;
    const person: Person = {};
    person['000'] = {name:'john', role:'admin'}
    person['111'] = {name:'jane', role:'owner'}

    type PageInfo = {
        id: string,
        name: string,
    }

    type Page = {
        Home: PageInfo,
        About: PageInfo,
        Contact: PageInfo
    };

    // instead of above code
    type page = Record<'home' | 'about' | 'contact', PageInfo>;

- auto complete trick:
    type padding1 = 'small' | 'medium' | 'large' | string;
    // its not giving auto complete
    const padd1: padding1 = 'small';
    const padd2: padding1 = '80px';

    // to give autoc complete while typing
    type padding2 = 'small' | 'medium' | 'large' | (string & {});
    const padd3: padding2 = 'large';
    const padd4: padding2 = 'medium';

- satisfies type
    type Perons = {
        name: string;
        age: number;
        occupation: string;
    }

    const person = {
        name: 'vivek',
        age: 45,
        occupation: 'developer'
    } satisfies Perons              // is equivalent to type Perons or not checking


    const person2 = {
        name: 'vivek',
        age: 45,
    } satisfies Perons          // this doesn't so giving error

    // or else you can do

    const per3 = {
        name: 'vivek',
        age: 45,
        occupation: 'developer'
    }

    const p4: Perons = per3;            // i'm able to assign per3 to p4, so per3 is type of person

- 
---------------------------------------------------------------------------------------------------